import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:json_annotation/json_annotation.dart';
import 'user_model.dart';

part 'follow_model.freezed.dart';
part 'follow_model.g.dart';

@freezed
class Follow with _$Follow {
  const factory Follow({
    required String id,
    required String followerId,
    required String followingId,
    required DateTime createdAt,
    User? follower,
    User? following,
  }) = _Follow;

  factory Follow.fromJson(Map<String, dynamic> json) => _$FollowFromJson(json);

  const Follow._();

  // Check if this follow involves a specific user
  bool involvesUser(String userId) {
    return followerId == userId || followingId == userId;
  }

  // Check if user is the follower
  bool isUserFollower(String userId) {
    return followerId == userId;
  }

  // Check if user is being followed
  bool isUserFollowing(String userId) {
    return followingId == userId;
  }

  // Get the other user in the follow relationship
  String? getOtherUserId(String userId) {
    if (followerId == userId) return followingId;
    if (followingId == userId) return followerId;
    return null;
  }

  // Get the other user object
  User? getOtherUser(String userId) {
    if (followerId == userId) return following;
    if (followingId == userId) return follower;
    return null;
  }

  // Create from database row
  factory Follow.fromDatabase(Map<String, dynamic> row) {
    return Follow(
      id: row['id'],
      followerId: row['follower_id'],
      followingId: row['following_id'],
      createdAt: DateTime.parse(row['created_at']),
    );
  }

  // Create minimal follow object
  factory Follow.minimal({
    required String followerId,
    required String followingId,
  }) {
    return Follow(
      id: '', // Will be generated by database
      followerId: followerId,
      followingId: followingId,
      createdAt: DateTime.now(),
    );
  }

  // Convert to map for database operations
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'follower_id': followerId,
      'following_id': followingId,
      'created_at': createdAt.toIso8601String(),
    };
  }
}

@freezed
class FollowRequest with _$FollowRequest {
  const factory FollowRequest({
    required String id,
    required String requesterId,
    required String targetUserId,
    required DateTime createdAt,
    String? message,
    @JsonKey(
      defaultValue: 'pending',
      fromJson: _followRequestStatusFromJson,
      toJson: _followRequestStatusToJson,
    )
    @Default(FollowRequestStatus.pending) FollowRequestStatus status,
    DateTime? respondedAt,
    User? requester,
    User? targetUser,
  }) = _FollowRequest;

  factory FollowRequest.fromJson(Map<String, dynamic> json) => _$FollowRequestFromJson(json);

  const FollowRequest._();

  // Check if request involves a specific user
  bool involvesUser(String userId) {
    return requesterId == userId || targetUserId == userId;
  }

  // Check if user is the requester
  bool isUserRequester(String userId) {
    return requesterId == userId;
  }

  // Check if user is the target
  bool isUserTarget(String userId) {
    return targetUserId == userId;
  }

  // Get the other user in the request
  String? getOtherUserId(String userId) {
    if (requesterId == userId) return targetUserId;
    if (targetUserId == userId) return requesterId;
    return null;
  }

  // Get the other user object
  User? getOtherUser(String userId) {
    if (requesterId == userId) return targetUser;
    if (targetUserId == userId) return requester;
    return null;
  }

  // Check if request is pending
  bool get isPending => status == FollowRequestStatus.pending;

  // Check if request is accepted
  bool get isAccepted => status == FollowRequestStatus.accepted;

  // Check if request is rejected
  bool get isRejected => status == FollowRequestStatus.rejected;

  // Accept the request
  FollowRequest accept() {
    return copyWith(
      status: FollowRequestStatus.accepted,
      respondedAt: DateTime.now(),
    );
  }

  // Reject the request
  FollowRequest reject() {
    return copyWith(
      status: FollowRequestStatus.rejected,
      respondedAt: DateTime.now(),
    );
  }

  // Create from database row
  factory FollowRequest.fromDatabase(Map<String, dynamic> row) {
    return FollowRequest(
      id: row['id'],
      requesterId: row['requester_id'],
      targetUserId: row['target_user_id'],
      createdAt: DateTime.parse(row['created_at']),
      message: row['message'],
      status: _followRequestStatusFromJson(row['status']),
      respondedAt: row['responded_at'] != null
          ? DateTime.parse(row['responded_at'])
          : null,
    );
  }

  // Convert to map for database operations
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'requester_id': requesterId,
      'target_user_id': targetUserId,
      'created_at': createdAt.toIso8601String(),
      'message': message,
      'status': status.name,
      'responded_at': respondedAt?.toIso8601String(),
    };
  }
}

// Follow request status enum
enum FollowRequestStatus {
  pending,
  accepted,
  rejected;

  String get label {
    switch (this) {
      case FollowRequestStatus.pending:
        return 'Pending';
      case FollowRequestStatus.accepted:
        return 'Accepted';
      case FollowRequestStatus.rejected:
        return 'Rejected';
    }
  }

  // Check if request is active (not resolved)
  bool get isActive => this == FollowRequestStatus.pending;

  // Check if request is resolved
  bool get isResolved => this == FollowRequestStatus.accepted || this == FollowRequestStatus.rejected;
}

// Follow statistics
@freezed
class FollowStats with _$FollowStats {
  const factory FollowStats({
    @Default(0) int followersCount,
    @Default(0) int followingCount,
    @Default(0) int pendingRequestsCount,
    @Default([]) List<Follow> recentFollowers,
    @Default([]) List<Follow> recentFollowing,
  }) = _FollowStats;

  factory FollowStats.fromJson(Map<String, dynamic> json) => _$FollowStatsFromJson(json);

  const FollowStats._();

  // Check if user has any followers
  bool get hasFollowers => followersCount > 0;

  // Check if user follows anyone
  bool get hasFollowing => followingCount > 0;

  // Check if user has pending follow requests
  bool get hasPendingRequests => pendingRequestsCount > 0;

  // Get total connections
  int get totalConnections => followersCount + followingCount;

  // Format counts for display
  String get formattedFollowersCount {
    if (followersCount >= 1000000) {
      return '${(followersCount / 1000000).toStringAsFixed(1)}M';
    } else if (followersCount >= 1000) {
      return '${(followersCount / 1000).toStringAsFixed(1)}K';
    }
    return followersCount.toString();
  }

  String get formattedFollowingCount {
    if (followingCount >= 1000000) {
      return '${(followingCount / 1000000).toStringAsFixed(1)}M';
    } else if (followingCount >= 1000) {
      return '${(followingCount / 1000).toStringAsFixed(1)}K';
    }
    return followingCount.toString();
  }

  String get formattedPendingRequestsCount {
    if (pendingRequestsCount >= 1000) {
      return '${(pendingRequestsCount / 1000).toStringAsFixed(1)}K';
    }
    return pendingRequestsCount.toString();
  }
}

// Follow-related enums and types
enum FollowSortOption {
  newest('Newest First'),
  oldest('Oldest First'),
  username('Username A-Z'),
  usernameDesc('Username Z-A');

  const FollowSortOption(this.label);
  final String label;
}

enum FollowFilterOption {
  all('All'),
  mutual('Mutual'),
  verified('Verified'),
  recent('Recent');

  const FollowFilterOption(this.label);
  final String label;
}

// JSON converter functions for FollowRequestStatus
FollowRequestStatus _followRequestStatusFromJson(String? json) {
  if (json == null) return FollowRequestStatus.pending;
  return FollowRequestStatus.values.firstWhere(
    (status) => status.name == json,
    orElse: () => FollowRequestStatus.pending,
  );
}

String _followRequestStatusToJson(FollowRequestStatus status) {
  return status.name;
}